### `创建索引的优势`

- 提高数据的检索速度，降低数据库IO成本：使用索引的意义就是通过缩小表中需要查询的记录的数目从而加快搜索的速度。
- 降低数据排序的成本，降低CPU消耗：索引之所以查的快，是因为先将数据排好序，若该字段正好需要排序，则真好降低了排序的成本。



### `创建索引的劣势`
- 占用存储空间：索引实际上也是一张表，记录了主键与索引字段，一般以索引文件的形式存储在磁盘上。
- 降低更新表的速度：表的数据发生了变化，对应的索引也需要一起变更，从而减低的更新速度。否则索引指向的物理数据可能不对，这也是索引失效的原因之一。
- 优质索引创建难：索引的创建并非一日之功，也并非一直不变。需要频繁根据用户的行为和具体的业务逻辑去创建最佳的索引。



### `索引分类`

我们常说的索引一般指的是BTree（多路搜索树）结构组织的索引。其中还有
`聚合索引`，`次要索引`，`复合索引`，`前缀索引`，`唯一索引`，统称`索引`，当然除了B+树外，还有哈希索引（hash index）等。



- 单值索引：一个索引只包含单个列，一个表可以有多个单列索引
- 唯一索引：索引列的值必须唯一，但允许有空值
- 复合索引：一个索引包含多个列，实际开发中推荐使用

> 实际开发中推荐使用复合索引，并且单表创建的索引个数建议不要超过五个


### `基本语法`

```shell
create [unique] index indexName on tableName (columnName...)
alter tableName add [unique] index [indexName] on (columnName...)

drop index [indexName] on tableName

show index from tableName
```



### `哪些情况需要建索引`
- 主键，唯一索引
- 经常用作查询条件的字段需要创建索引
- 经常需要排序、分组和统计的字段需要建立索引
- 查询中与其他表关联的字段，外键关系建立索引



### `哪些情况不要建索引`
- 表的记录太少，百万级以下的数据不需要创建索引
- 经常增删改的表不需要创建索引
- 数据重复且分布平均的字段不需要创建索引，如 true,false 之类。
- 频发更新的字段不适合创建索引
- where条件里用不到的字段不需要创建索引



### `性能分析`

#### `MySQL` 自身瓶颈

`MySQL`自身参见的性能问题有磁盘空间不足，磁盘I/O太大，服务器硬件性能低。
- `CPU`：CPU 在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候
- `IO`：磁盘I/O 瓶颈发生在装入数据远大于内存容量的时候
- 服务器硬件的性能瓶颈：top,free,iostat 和 vmstat来查看系统的性能状态



### `explain` 分析`sql`语句

使用`explain`关键字可以模拟优化器执行sql查询语句，从而得知MySQL 是如何处理sql语句。



```shell
+----+-------------+-------+------------+------+---------------+-----+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+-----+---------+------+------+----------+-------+
```





#### `id`

`select` 查询的序列号，包含一组可以重复的数字，表示查询中执行sql语句的顺序。一般有三种情况：
- `id`全部相同，sql的执行顺序是由上至下；
- `id`全部不同，sql的执行顺序是根据id大的优先执行；
- `id`既存在相同，又存在不同的。先根据id大的优先执行，再根据相同id从上至下的执行。



#### `select_type`

`select` 查询的类型，主要是用于区别普通查询，联合查询，嵌套的复杂查询
`simple`：简单的select 查询，查询中不包含子查询或者union
`primary`：查询中若包含任何复杂的子查询，最外层查询则被标记为primary
`subquery`：在select或where 列表中包含了子查询
`derived`：在from列表中包含的子查询被标记为derived（衍生）MySQL会递归执行这些子查询，把结果放在临时表里。
`union`：若第二个select出现在union之后，则被标记为union，若union包含在from子句的子查询中，外层select将被标记为：derived
`union result`：从union表获取结果的select



#### `partitions`

表所使用的分区，如果要统计十年公司订单的金额，可以把数据分为十个区，每一年代表一个区。这样可以大大的提高查询效率。


#### `type`

这是一个非常重要的参数，连接类型，常见的有：`all` , `index` , `range` , `ref` , `eq_ref` , `const` , `system` , `null` 八个级别。性能从最优到最差的排序：`system` > `const` > `eq_ref` > `ref` > `range` > `index` > `all`。



对程序员来说，若保证查询至少达到`range`级别或者最好能达到ref则算是一个优秀而又负责的程序员。


- `all`：（full table scan）全表扫描无疑是最差，若是百万千万级数据量，全表扫描会非常慢。
- `index`：（full index scan）全索引文件扫描比all好很多，毕竟从索引树中找数据，比从全表中找数据要快。
- `range`：只检索给定范围的行，使用索引来匹配行。范围缩小了，当然比全表扫描和全索引文件扫描要快。sql语句中一般会有between，in，>，< 等查询。
- `ref`：非唯一性索引扫描，本质上也是一种索引访问，返回所有匹配某个单独值的行。比如查询公司所有属于研发团队的同事，匹配的结果是多个并非唯一值。
- `eq_ref`：唯一性索引扫描，对于每个索引键，表中有一条记录与之匹配。比如查询公司的CEO，匹配的结果只可能是一条记录，
- `const`：表示通过索引一次就可以找到，const用于比较primary key 或者unique索引。因为只匹配一行数据，所以很快，若将主键至于where列表中，MySQL就能将该查询转换为一个常量。
- `system`：表只有一条记录（等于系统表），这是const类型的特列，平时不会出现，了解即可



#### `possible_keys`

显示查询语句可能用到的索引(一个或多个或为null)，不一定被查询实际使用。仅供参考使用。


#### `key`

显示查询语句实际使用的索引。若为null，则表示没有使用索引。


#### `key_len`

显示索引中使用的字节数，可通过key_len计算查询中使用的索引长度。在不损失精确性的情况下索引长度越短越好。key_len 显示的值为索引字段的最可能长度，并非实际使用长度，即key_len是根据表定义计算而得，并不是通过表内检索出的。


#### `ref`
显示索引的哪一列或常量被用于查找索引列上的值。


#### `rows`

根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数，值越大越不好。


#### `extra`

- `Using filesort`：说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序” 。出现这个就要立刻优化sql。
- `Using temporary`：使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于排序 order by 和 分组查询 group by。出现这个更要立刻优化sql。
- `Using index`：表示相应的select 操作中使用了覆盖索引（Covering index），避免访问了表的数据行，效果不错！如果同时出现Using where，表明索引被用来执行索引键值的查找。如果没有同时出现Using where，表示索引用来读取数据而非执行查找动作。
- `覆盖索引`（Covering Index） ：也叫索引覆盖，就是select 的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select 列表中的字段，而不必根据索引再次读取数据文件。
- `Using index condition`：在5.6版本后加入的新特性，优化器会在索引存在的情况下，通过符合RANGE范围的条数 和 总数的比例来选择是使用索引还是进行全表遍历。
- `Using where`：表明使用了where 过滤。
- `Using join buffer`：表明使用了连接缓存。
- `impossible where`：where 语句的值总是false，不可用，不能用来获取任何元素。
- `distinct`：优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作。
- `filtered` 一个百分比的值，和rows 列的值一起使用，可以估计出查询执行计划(QEP)中的前一个表的结果集，从而确定join操作的循环次数。小表驱动大表，减轻连接的次数。



#### 通过`explain`的参数介绍，我们可以得知
- 表的读取顺序(id)
- 数据读取操作的操作类型(type)
- 哪些索引被实际使用(key)
- 表之间的引用(ref)
- 每张表有多少行被优化器查询(rows)



### `性能下降的原因`

从程序员的角度
- 查询语句写的不好
- 没建索引，索引建的不合理或索引失效
- 关联查询有太多的join

从服务器的角度
- 服务器磁盘空间不足
- 服务器调优配置参数设置不合理



### `总结`

1. 索引是排好序且快速查找的数据结构。其目的是为了提高查询的效率。
   
2. 创建索引后，查询数据变快，但更新数据变慢。
   
3. 性能下降的原因很可能是索引失效导致。
   
4. 索引创建的原则，经常查询的字段适合创建索引，频繁需要更新的数据不适合创建索引。
   
5. 索引字段频繁更新，或者表数据物理删除容易造成索引失效。
   
6. 擅用 `explain` 分析`sql`语句
   
7. 除了优化sql语句外，还可以优化表的设计。如尽量做成单表查询，减少表之间的关联。设计归档表等。


> 感谢：[好好学java](https://mp.weixin.qq.com/s/Jtz_dMoKln1tuTQYEjsY-A)






### 基础
讲联合索引，一定要扯最左匹配!放心，我不扯有的没的，几句话懂个大概就行！

### 最左匹配

所谓最左原则指的就是如果你的 SQL 语句中用到了联合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个联合索引去进行匹配，值得注意的是，当遇到范围查询(>、<、between、like)就会停止匹配。

假设，我们对(a,b)字段建立一个索引，也就是说，你where后条件为

`a = 1
a = 1 and b = 2`
是可以匹配索引的。但是要注意的是~你执行

`b= 2 and a =1`
也是能匹配到索引的，因为Mysql有优化器会自动调整a,b的顺序与索引顺序一致。 相反的，你执行
`b = 2`
就匹配不到索引了。 而你对`(a,b,c,d)`建立索引,where后条件为
`a = 1 and b = 2 and c > 3 and d = 4`

那么，a,b,c三个字段能用到索引，而d就匹配不到。因为遇到了范围查询！

最左匹配的原理？

假设，我们对(a,b)字段建立索引，那么入下图所示

![](https://pic2.zhimg.com/80/v2-fcde0ef783885b6b17999f39ca2808b5_1440w.jpg)


如图所示他们是按照a来进行排序，在a相等的情况下，才按b来排序。

因此，我们可以看到a是有序的1，1，2，2，3，3。而b是一种全局无序，局部相对有序状态! 什么意思呢？

从全局来看，b的值为1，2，1，4，1，2，是无序的，因此直接执行b = 2这种查询条件没有办法利用索引。

从局部来看，当a的值确定的时候，b是有序的。例如a = 1时，b值为1，2是有序的状态。当a=2时候，b的值为1,4也是有序状态。 因此，你执行a = 1 and b = 2是a,b字段能用到索引的。而你执行a > 1 and b = 2时，a字段能用到索引，b字段用不到索引。因为a的值此时是一个范围，不是固定的，`在这个范围内b值不是有序的，因此b字段用不上索引`。

综上所示，`最左匹配原则`，`在遇到范围查询的时候，就会停止匹配`。

实战
OK，懂上面的基础，我们就可以开始扯了~我举了经典的五大题型，看完基本就懂！

题型一
如果sql为

`SELECT * FROM table WHERE a = 1 and b = 2 and c = 3;`

如何建立索引?

如果此题回答为对(a,b,c)建立索引，那都可以回去等通知了。 此题正确答法是，(a,b,c)或者(c,b,a)或者(b,a,c)都可以，重点要的是将区分度高的字段放在前面，区分度低的字段放后面。像性别、状态这种字段区分度就很低，我们一般放后面。

例如假设区分度由大到小为b,a,c。那么我们就对(b,a,c)建立索引。在执行sql的时候，优化器会 帮我们调整where后a,b,c的顺序，让我们用上索引。

题型二
如果sql为

`SELECT * FROM table WHERE a > 1 and b = 2;`

如何建立索引?

如果此题回答为对(a,b)建立索引，那都可以回去等通知了。 此题正确答法是，对(b,a)建立索引。如果你建立的是(a,b)索引，那么只有a字段能用得上索引，毕竟最左匹配原则遇到范围查询就停止匹配。 如果对(b,a)建立索引那么两个字段都能用上，优化器会帮我们调整where后a,b的顺序，让我们用上索引。

题型三
如果sql为

`SELECT * FROM `table` WHERE a > 1 and b = 2 and c > 3;`

如何建立索引? 此题回答也是不一定，(b,a)或者(b,c)都可以，要结合具体情况具体分析。

拓展一下

`SELECT * FROM `table` WHERE a = 1 and b = 2 and c > 3;`

怎么建索引？嗯，大家一定都懂了！

题型四
`SELECT * FROM `table` WHERE a = 1 ORDER BY b;`

如何建立索引？ 这还需要想？一看就是对(a,b)建索引，当a = 1的时候，b相对有序，可以避免再次排序！ 那么

`SELECT * FROM `table` WHERE a > 1 ORDER BY b;`

如何建立索引？ 对(a)建立索引，因为a的值是一个范围，这个范围内b值是无序的，没有必要对(a,b)建立索引。

拓展一下

`SELECT * FROM `table` WHERE a = 1 AND b = 2 AND c > 3 ORDER BY c;`

怎么建索引?

题型五
`SELECT * FROM `table` WHERE a IN (1,2,3) and b > 1;`

如何建立索引？

还是对(a，b)建立索引，因为IN在这里可以视为等值引用，不会中止索引匹配，所以还是(a,b)!

拓展一下

`SELECT * FROM `table` WHERE a = 1 AND b IN (1,2,3) AND c > 3 ORDER BY c;`

如何建立索引？此时c排序是用不到索引的。



> 再次参考傲丙的文章 [我以为我对数据库索引很了解?](https://zhuanlan.zhihu.com/p/107487215)


